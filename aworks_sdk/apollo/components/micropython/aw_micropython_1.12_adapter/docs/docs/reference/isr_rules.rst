.. _isr_rules:

编写中断处理程序
==========================

在合适的硬件上， MicroPython 提供了Python编写中断处理程序的功能。中断处理程序（也称为中断服务程序（ISR））定义为回调函数。这些响应于 诸如定时器触发或引脚上的电压变化之类的时间而执行。此类事件可以在程序代码执行的任何时候发生。这会带来严重的后果，某些后果是 MicroPython语言所特有的，其他所有对于能够响应实时事件的系统都是通用的。本文档首先介绍特定于语言的问题， 然后针对新手简要介绍实时编程。

介绍中使用了一些诸如“慢”、“尽可能快”等模糊语言，这并非无意为之，因为速度取决于应用程序。ISR可接受的
持续时间取决于多个因素：中断发生的速度、主程序的性质和其他并发事件的存在。

提示和推荐做法
------------------------------

此处总结了以下详细内容，并列出了有关中断处理程序代码的主要建议。


* 使代码尽可能简短。
* 避免分配内存：无附加列表或插入字典，无浮点数。
* 考虑使用 ``micropython.schedule`` 来解决上述约束。
* 在ISR返回多个字节的情况下，使用预先分配的 ``bytearray`` 。若在ISR和主程序之间共享多个人整数，则使用数组（ ``array.array`` ）.
* 在主程序和ISR之间共享数据的情况下，考虑在主程序中访问数据前禁用中断，并在此后立即重新启用（请参见Critical 章节）.
* 分配紧急异常缓冲区（请参见下文）。


MicroPython 问题
------------------

紧急异常缓冲区
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果ISR中发生错误，除非为此目的创建了特殊的缓冲区，否则 MicroPython 无法生成错误报告，如果使用中断的任何程序中包含以下代码，则调试将得到简化。

.. code:: python

    import micropython
    micropython.alloc_emergency_exception_buf(100)


紧急异常缓冲区只能保存一个异常堆栈跟踪。这意味着，如果在堆被锁定时在处理异常期间抛出了第二个异常，则即使对第二个异常进行了干净处理，该第二个异常的堆栈跟踪也将替换原始的堆栈跟踪，如果以后打印缓冲区，这可能导致混乱的异常消息。

简化
~~~~~~~~~~

由于多种原因，保持ISR代码尽可能短而简单很重要。它仅应执行引起该事件的事件之后必须立即执行的操作：应将可以推迟的操作委托给主程序循环。通常，ISR将处理引起中断的硬件设备，使其准备好发生下一个中断。它将通过更新共享数据以指示中断已发生而与主循环通信，然后它将返回。一个ISR应该尽快将控制权返回给主循环。这不是 MicroPython的特定问题，因此在  :ref:`below <ISR>` 有更详细的介绍。

ISR与主程序之间的通信
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

通常，ISR需要与主程序进行通信。最简单的方法是通过一个或多个共享数据对象，这些对象可以声明为全局或者通过类共享（请参见下文）。这样做有各种限制和危险，下面将详细介绍。整数， ``bytes`` and ``bytearray`` 对象通常与可存储各种数据类型的数组（来自array模块）一起用于此目的。

使用对象方法作为回调
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MicroPython 支持这项强大的技术，该技术使ISR可以与基础代码共享实例变量。它还是实现设备驱动程序的类支持多个设备实例。一下示例是两个LED以不同的速率闪烁。

.. code:: python

    import pyb, micropython
    micropython.alloc_emergency_exception_buf(100)
    class Foo(object):
        def __init__(self, timer, led):
            self.led = led
            timer.callback(self.cb)
        def cb(self, tim):
            self.led.toggle()

    red = Foo(pyb.Timer(4, freq=1), pyb.LED(1))
    green = Foo(pyb.Timer(2, freq=0.8), pyb.LED(2))

在此示例中， ``red`` 实例将定时器4与LED 1关联：当定时器4中断发生时， ``red.cb()`` 被调用，导致LED 1更改状态。 ``green`` 实例的操作类似：定时器2中断导致执行 ``green.cb()`` 并切换LED2状态。使用实例方法可带来两个好处。首先，单个类使代码可以在多个硬件实例之间共享。其次，作为绑定方法，回调函数的第一个参数是 ``self`` 。这使回调能够访问实例数据并保存连续调用之间的状态。例如，如果上面的类在构造函数中将变量 ``self.count`` 设置为零，则 ``cb()`` 可以使计数器递增，然后， ``red`` 和 ``green`` 实例将对每个LED更改状态的次数保持独立的计数。

创建Python对象
~~~~~~~~~~~~~~~~~~~~~~~~~~

ISR无法创建Python对象的实例。这是因为 MicroPython需要从称为堆的空闲内存块存储中为对象分配内存，这在中断处理程序中是不允许的，因为堆分配并非可重入的。换句话说，当主程序着呢挂在执行分配时，中断可能会发生——为维护堆的完整性，解释器不允许在ISR代码中进行内存分配。

其影响之一是ISR无法使用浮点算法；这是因为浮点数为Python对象。类似地，ISR无法附项目到列表中，实际上，很难精准确定哪个代码结构将尝试执行内存分配并引发错误信息：使ISR代码尽可能简短的另一原因。

避免此问题的一种方法是让ISR使用预分配的缓冲区。例如，一个类构造函数创建一个 ``bytearray`` 实例和一个布尔标志，ISR将数据分配到缓冲区中的位置标志。实例化对象时，内存分配发生在主程序代码中，而不是ISR中。

MicroPython库的I/O方法通常提供使用预分配缓冲区的选项。例如， ``pyb.i2c.recv()`` 可以接受可变缓冲区作为第一个参数：这使它可以在ISR中使用。

不使用类或全局变量而创建对象的方法如下：

.. code:: python

    def set_volume(t, buf=bytearray(3)):
        buf[0] = 0xa5
        buf[1] = t >> 4
        buf[2] = 0x5a
        return buf

首次加载函数时，编译器会实例化默认 ``        
buf`` 参数（通常在其所在模块被导入时）。

创建对绑定方法的引用时，将发生对象实例的创建。这意味着ISR无法将绑定方法传递给函数。一种解决方案是在类构造函数中创建对绑定方法的引用，并在ISR中传递该引用。例如：

.. code:: python

    class Foo():
        def __init__(self):
            self.bar_ref = self.bar  # Allocation occurs here
            self.x = 0.1
            tim = pyb.Timer(4)
            tim.init(freq=2)
            tim.callback(self.cb)

        def bar(self, _):
            self.x *= 1.2
            print(self.x)

        def cb(self, t):
            # Passing self.bar would cause allocation.
            micropython.schedule(self.bar_ref, 0)

其他技术是在构造函数中定义和实例化该方法，或者将 *self* 参数传递给 :meth:`Foo.bar` 。

使用 Python 对象
~~~~~~~~~~~~~~~~~~~~~

由于Python的工作方式，对对象的进一步限制也随之出现。当执行import语句时，Python代码将编译为字节码，其中一行代码通常映射到多个字节码。代码运行时，解释器读取每个字节代码，并将其作为一系列机器代码指令执行。鉴于在机器代码指令之间的任何时间都可能发生中断，因此原始Python代码行可能仅部分执行。因此，在发生中断时，在主循环中修改的Python对象（例如集合，列表或字典）可能缺乏内部一致性。

典型的结果如下。在极少数情况下，ISR会在对象部分更新的准确时间运行。当ISR尝试读取对象时，将导致崩溃。由于此类问题通常发生在极少数随机情况下，因此很难诊断。有一些方法可以避免此问题，请参见 :ref:`Critical Sections <Critical>` 。

了解对象的更改的组成很重要，对内置类型（例如字典）的更改是有问题的。不能更改数组或字节数组的内容，这是因为字节或字是作为不可中断的单个机器代码指令编写的：在实时编程中，写入是原子的。用户定义的对象可以实例化整数，数组或字节数组。对于主循环和ISR更改它们的内容都是有效的。

MicroPython支持任意精度的整数。2 ** 30 -1和-2 ** 30之间的值将存储在单个机器字中。较大的值存储为Python对象。因此，对长整数的更改不能视为是原子的。在ISR中使用长整数是不安全的，因为随着变量值的更改，可能会尝试分配内存。

更多内容请参考  `编写中断处理程序 <https://docs.micropython.org/en/lastest/reference/isr_rules.html>`_ 。